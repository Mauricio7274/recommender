# -*- coding: utf-8 -*-
"""Untitled6.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1L0O4ntPe3lFtPo_RfYCX8MhISvCuAhO4
"""

# eclat.py

from recommender import transactions


def create_tidsets(transactions):
    tidsets = {}
    for tid, transaction in enumerate(transactions):
        for item in transaction:
            if item not in tidsets:
                tidsets[item] = set()
            tidsets[item].add(tid)
    return tidsets


def calculate_support(itemset, tidsets):
    return len(set.intersection(*[tidsets[item] for item in itemset]))


def generate_candidates(itemsets, length):
    candidates = set()
    itemsets_list = list(itemsets)
    for i in range(len(itemsets_list)):
        for j in range(i + 1, len(itemsets_list)):
            union_set = itemsets_list[i].union(itemsets_list[j])
            if len(union_set) == length:
                candidates.add(union_set)
    return candidates


def eclat(transactions, min_support):
    tidsets = create_tidsets(transactions)
    itemsets = set(frozenset([item]) for item in tidsets)
    valid_itemsets = []
    k = 1
    while itemsets:
        current_itemsets = [itemset for itemset in itemsets if calculate_support(itemset, tidsets) >= min_support]
        valid_itemsets.extend(current_itemsets)
        k += 1
        itemsets = generate_candidates(set(current_itemsets), k)
    return valid_itemsets, tidsets


def calculate_metrics(itemset, tidsets, total_transactions):
    support_itemset = calculate_support(itemset, tidsets)
    support = support_itemset / total_transactions

    item_supports = {item: len(tidsets[item]) / total_transactions for item in itemset}

    metrics = {
        'support': support,
        'confidence': {},
        'lift': {},
        'leverage': {},
        'odds_ratio': {}
    }

    for item in itemset:
        confidence = support / item_supports[item] if item_supports[item] != 0 else 0
        metrics['confidence'][item] = confidence

    for a in itemset:
        for b in itemset:
            if a != b:
                support_a = item_supports[a]
                support_b = item_supports[b]
                lift = support / (support_a * support_b) if (support_a * support_b) != 0 else 0
                leverage = support - (support_a * support_b)
                odds_ratio = (support * (1 - support_a) * (1 - support_b)) / ((support_a - support) * (support_b - support)) if (support_a - support) * (support_b - support) != 0 else 0

                metrics['lift'][(a, b)] = lift
                metrics['leverage'][(a, b)] = leverage
                metrics['odds_ratio'][(a, b)] = odds_ratio

    return metrics


def filter_always_together(itemsets, tidsets, total_transactions):
    return [itemset for itemset in itemsets if calculate_support(itemset, tidsets) != total_transactions]


def get_recommendations(itemsets, tidsets, total_transactions):
    recommendations = {}
    for itemset in itemsets:
        metrics = calculate_metrics(itemset, tidsets, total_transactions)
        for item in itemset:
            if item not in recommendations:
                recommendations[item] = []
            for other_item in itemset:
                if item != other_item:
                    score = metrics['lift'].get((item, other_item), 0)
                    recommendations[item].append((other_item, score))

    for item in recommendations:

        seen = set()
        unique_recs = []
        for other_item, score in recommendations[item]:
            if other_item not in seen:
                unique_recs.append((other_item, score))
                seen.add(other_item)
        recommendations[item] = sorted(unique_recs, key=lambda x: x[1], reverse=True)[:3]

    return recommendations


min_support = 3


itemsets, tidsets = eclat(transactions, min_support)
filtered_itemsets = filter_always_together(itemsets, tidsets, len(transactions))


recommendations = get_recommendations(filtered_itemsets, tidsets, len(transactions))


for item, recs in recommendations.items():
    print(f"Item: {item}")
    for other_item, score in recs:
        print(f"  Recommend: {other_item}")